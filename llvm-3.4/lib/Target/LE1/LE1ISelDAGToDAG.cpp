//===-- LE1ISelDAGToDAG.cpp - A dag to dag inst selector for LE1 --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the LE1 target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "le1-isel"
#include "LE1.h"
#include "LE1MachineFunction.h"
#include "LE1RegisterInfo.h"
#include "LE1Subtarget.h"
#include "LE1TargetMachine.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Type.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/CFG.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

#include <iostream>

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// LE1DAGToDAGISel - LE1 specific code to select LE1 machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace {

class LE1DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the LE1Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const LE1Subtarget &Subtarget;

  /// TM - Keep a reference to LE1TargetMachine.
  LE1TargetMachine &TM;
  const LE1InstrInfo *TII;

public:
  explicit LE1DAGToDAGISel(LE1TargetMachine &tm) :
  SelectionDAGISel(tm),
  Subtarget(tm.getSubtarget<LE1Subtarget>()),
  TM(tm),
  TII(static_cast<const LE1InstrInfo*>(TM.getInstrInfo())) {
  }

  // Pass Name
  virtual const char *getPassName() const {
    return "LE1 DAG->DAG Pattern Instruction Selection";
  }


private:
  // Include the pieces autogenerated from the target description.
  #include "LE1GenDAGISel.inc"

  /// getTargetMachine - Return a reference to the TargetMachine, casted
  /// to the target-specific type.
  const LE1TargetMachine &getTargetMachine() {
    return static_cast<const LE1TargetMachine &>(TM);
  }

  /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
  /// to the target-specific type.
  const LE1InstrInfo *getInstrInfo() {
    return getTargetMachine().getInstrInfo();
  }

  //SDNode *getGlobalBaseReg();
  SDNode *Select(SDNode *N);

  // Complex Pattern.
  bool SelectAddri8(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddri12(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddri32(SDValue Addr, SDValue &Base, SDValue &Offset);

  // getI32Imm - Return a target constant with the specified
  // value, of type i32.
  inline SDValue getI32Imm(unsigned Imm) {
    return CurDAG->getTargetConstant(Imm, MVT::i32);
  }

  virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                            char ConstraintCode,
                                            std::vector<SDValue> &OutOps);
};

}

bool LE1DAGToDAGISel::SelectAddri8(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  DEBUG(dbgs() << "SelectAddri8\n");
  EVT VT = Addr.getValueType();
  SDLoc dl(Addr.getNode());

  if (dyn_cast<GlobalAddressSDNode>(Addr))
    return false;

  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), VT);
    Offset = CurDAG->getTargetConstant(0, VT);
    DEBUG(dbgs() << "Addr is FrameIndex, SelectAddri8 pass\n");
    return true;
  }

  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    DEBUG(dbgs() << "isBaseWithConstantOffset\n");
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1)))
    {
      DEBUG(dbgs() << "Offset = " << CN->getZExtValue() << "\n");

      if (CN->getZExtValue() == (CN->getZExtValue() & 0xFF)) {
        Base = Addr.getOperand(0);
        Offset = Addr.getOperand(1);
        DEBUG(dbgs() << "SelectAddri8 pass, BaseWithConstantOFfset\n");
        return true;
      }
    }
    DEBUG(dbgs() << "BaseWithConstantOffset, SelectAddri8 fail\n");
  }
  else {
    DEBUG(dbgs() << "SelectAddri8 pass, just using default\n");
    Base = Addr.getOperand(1);
    Offset = getI32Imm(0);
    return true;
  }
  /*
  else {
    SDValue LHS = Addr.getOperand(0);
    SDValue RHS = Addr.getOperand(1);
    Offset = getI32Imm(0);

    if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(RHS))
      RHS = CurDAG->getTargetFrameIndex(FIN->getIndex(), VT);

    // The address may be stored in a single register
    if (LHS.getValueType() == MVT::Other) {
      DEBUG(dbgs() << "SelectAddri8 pass with MVT::Other\n");
      Base = RHS;
      return true;
    }
    else if (RHS.getValueType() == MVT::Other) {
      DEBUG(dbgs() << "SelectAddri8 pass with MVT::Other");
      Base = LHS;
      return true;
    }

    // Address has bee calculated which the base and offset stored in registers.
    // Add these values to create the base, and use a zero offset. We also check
    // whether we are adding the result of a shift, if so we can possibly use
    // one of our SHADD instructions.
    if ((LHS.getOpcode() != ISD::SHL) && (RHS.getOpcode() != ISD::SHL)) {
      std::cout << "LHS = ";
      //LHS.dump();
      std::cout << "RHS = ";
      //RHS.dump();
      if (RHS.getOpcode() == ISD::UNDEF)
        Base = LHS;
      else {
        Base = SDValue(CurDAG->getMachineNode(LE1::ADDr, dl, VT, LHS, RHS), 0);
        DEBUG(dbgs() << "Creating ADDr node for address, SelectAddri8 pass\n");
        return true;
      }
      return true;
    }
    else {
      unsigned ShiftVal = 0;
      unsigned Opcode = 0;
      SDValue ShiftOp0;
      SDValue ShiftOp1;
      if (LHS.getOpcode() == ISD::SHL) {
        if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(LHS.getOperand(1))) {
          ShiftOp0 = LHS.getOperand(0);
          ShiftOp1 = RHS;
          ShiftVal = CN->getZExtValue();
        }
      }
      else if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(RHS.getOperand(1)))
      {
        ShiftOp0 = RHS.getOperand(0);
        ShiftOp1 = LHS;
        ShiftVal = CN->getZExtValue();
      }

      switch (ShiftVal) {
      default:
        Base = SDValue(CurDAG->getMachineNode(LE1::ADDr, dl, VT, LHS, RHS), 0);
        DEBUG(dbgs() << "SelectAddri8 success, using ADDr\n");
        return true;
      case 1:
        Opcode = LE1::SH1ADDr;
        break;
      case 2:
        Opcode = LE1::SH2ADDr;
        break;
      case 3:
        Opcode = LE1::SH3ADDr;
        break;
      case 4:
        Opcode = LE1::SH4ADDr;
        break;
      }
      Base = SDValue(CurDAG->getMachineNode(Opcode, dl, VT, ShiftOp0,
                                            ShiftOp1), 0);

      DEBUG(dbgs() << "Created shl op for addr, SelectAddri8 pass\n");
      return true;
    }
  }*/
  DEBUG(dbgs() << "Fail on SelectAddri8\n");
  return false;
}

// TODO Add functionality such as the i8 version, probably refactor
bool LE1DAGToDAGISel::SelectAddri12(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  EVT ValTy = Addr.getValueType();

  if (dyn_cast<GlobalAddressSDNode>(Addr))
    return false;

  if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
    Offset = getI32Imm(0);
    DEBUG(dbgs() << "SelectAddri12 success\n");
    return true;
  }
  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = cast<ConstantSDNode>(Addr.getOperand(1));
    if (CN->getZExtValue() == (CN->getZExtValue() & 0xFFF)) {
      Base = Addr.getOperand(0);
      Offset = Addr.getOperand(1);
      DEBUG(dbgs() << "SelectAddri12 success\n");
      return true;
    }
  }
  DEBUG(dbgs() << "SelectAddri12 fail\n");
  return false;
}

bool LE1DAGToDAGISel::SelectAddri32(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  DEBUG(dbgs() << "SelectAddri32 with ");
  SDLoc dl(Addr.getNode());

  if (Addr.getNode()->isTargetOpcode())
    DEBUG(dbgs() <<
          TM.getTargetLowering()->getTargetNodeName(Addr.getOpcode()));
  else
    DEBUG(dbgs() << Addr.getNode()->getOperationName());
  DEBUG(dbgs() << "\n");

  if (dyn_cast<FrameIndexSDNode>(Addr)) {
    DEBUG(dbgs() << "Addr is FrameIndex, SelectAddri32 fail\n");
    return false;
  }
  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Addr)) {
    Base = CurDAG->getRegister(LE1::ZERO, MVT::i32);
    Offset = CurDAG->getTargetGlobalAddress(GA->getGlobal(), dl, MVT::i32,
                                            GA->getOffset());
    DEBUG(dbgs() << "GlobalAddress, SelectAddri32 success\n");
    return true;
  }
  else if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
    DEBUG(dbgs() << "Offset = " << CN->getZExtValue() << "\n");

    if ((CN->getZExtValue() == (CN->getZExtValue() & 0xFF)) ||
       (CN->getZExtValue() == (CN->getZExtValue() & 0xFFF))) {
      DEBUG(dbgs() << "SelectAddri32 fail\n");
      return false;
    }

    Base = Addr.getOperand(0);
    Offset = CurDAG->getTargetConstant(CN->getZExtValue(), MVT::i32);
    DEBUG(dbgs() << "SelectAddri32 pass with Base + ConstantOffset\n");
    return true;
  }
  DEBUG(dbgs() << "SelectAddri32 fail\n");
  return false;
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* LE1DAGToDAGISel::Select(SDNode *Node) {

  unsigned Opcode = Node->getOpcode();
  SDLoc dl(Node);

  // Dump information about the Node being selected
  DEBUG(dbgs() << "Selecting:" << Opcode << "\n");
  DEBUG(Node->dump(CurDAG));

  switch(Opcode) {
  default:
    // Select the default instruction
    return SelectCode(Node);
    break;
  case ISD::GlobalAddress: {
    GlobalAddressSDNode *GA = cast<GlobalAddressSDNode>(Node);
    SDValue Addr = CurDAG->getTargetGlobalAddress(GA->getGlobal(),
                                                  dl, MVT::i32,
                                                  GA->getOffset());
    return CurDAG->getMachineNode(LE1::MOVi, dl, MVT::i32, Addr);
  }
  case ISD::FrameIndex: {
    FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Node);
    if (FIN->getIndex() == 0)
      return CurDAG->getRegister(LE1::ZERO, MVT::i32).getNode();
    SDValue Index = CurDAG->getTargetConstant(FIN->getIndex(), MVT::i32);
    return CurDAG->getMachineNode(LE1::MOVi, dl, MVT::i32, Index);
  }
  case LE1ISD::ADDCG: {
    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);
    SDValue Cin = Node->getOperand(2);
    return CurDAG->getMachineNode(LE1::ADDCG, dl, MVT::i32, MVT::i1, 
                                  LHS, RHS, Cin);
    break;
  }
  case LE1ISD::DIVS: {
    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);
    SDValue Cin = Node->getOperand(2);
    return CurDAG->getMachineNode(LE1::DIVS, dl, MVT::i32, MVT::i1,
                                  LHS, RHS, Cin);
    break;
  }
    //FIXME instructions should be given node names so selection is automatic
  case LE1ISD::MTB:
    return CurDAG->getMachineNode(LE1::MTB, dl, MVT::i1, Node->getOperand(0));
    break;
 case LE1ISD::MFB:
    return CurDAG->getMachineNode(LE1::MFB, dl, MVT::i32, Node->getOperand(0));
    break;
  case LE1ISD::SET_ATTR: {
    SDValue Chain = Node->getOperand(0);
    SDValue Value = Node->getOperand(1);
    SDValue Addr = Node->getOperand(2);
    SDNode *Result = CurDAG->getMachineNode(LE1::SetAttr, dl, MVT::Other,
                                            Value, Addr, Chain);
    //ReplaceUses(Node, Result);
    return Result;
    break;
  }
  case LE1ISD::NUM_CORES:
    return CurDAG->getMachineNode(LE1::LE1_NUM_CORES, dl, MVT::i32);
  }
  return SelectCode(Node);
}

bool LE1DAGToDAGISel::
SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
                             std::vector<SDValue> &OutOps) {
  assert(ConstraintCode == 'm' && "unexpected asm memory constraint");
  OutOps.push_back(Op);
  return false;
}

/// createLE1ISelDag - This pass converts a legalized DAG into a
/// LE1-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createLE1ISelDag(LE1TargetMachine &TM) {
  return new LE1DAGToDAGISel(TM);
}
