//===-- LE1ISelDAGToDAG.cpp - A dag to dag inst selector for LE1 --------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the LE1 target.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "le1-isel"
#include "LE1.h"
#include "LE1MachineFunction.h"
#include "LE1RegisterInfo.h"
#include "LE1Subtarget.h"
#include "LE1TargetMachine.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/IR/Type.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/CFG.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"

#include <iostream>

using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// LE1DAGToDAGISel - LE1 specific code to select LE1 machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace {

class LE1DAGToDAGISel : public SelectionDAGISel {
  /// Subtarget - Keep a pointer to the LE1Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const LE1Subtarget &Subtarget;

  /// TM - Keep a reference to LE1TargetMachine.
  LE1TargetMachine &TM;
  const LE1InstrInfo *TII;

public:
  explicit LE1DAGToDAGISel(LE1TargetMachine &tm) :
  SelectionDAGISel(tm),
  Subtarget(tm.getSubtarget<LE1Subtarget>()),
  TM(tm),
  TII(static_cast<const LE1InstrInfo*>(TM.getInstrInfo())) {
  }

  // Pass Name
  virtual const char *getPassName() const {
    return "LE1 DAG->DAG Pattern Instruction Selection";
  }


private:
  // Include the pieces autogenerated from the target description.
  #include "LE1GenDAGISel.inc"

  /// getTargetMachine - Return a reference to the TargetMachine, casted
  /// to the target-specific type.
  const LE1TargetMachine &getTargetMachine() {
    return static_cast<const LE1TargetMachine &>(TM);
  }

  /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
  /// to the target-specific type.
  const LE1InstrInfo *getInstrInfo() {
    return getTargetMachine().getInstrInfo();
  }

  //SDNode *getGlobalBaseReg();
  SDNode *Select(SDNode *N);

  // Complex Pattern.
  bool SelectAddri8(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddri12(SDValue Addr, SDValue &Base, SDValue &Offset);
  bool SelectAddri32(SDValue Addr, SDValue &Base, SDValue &Offset);

  // getI32Imm - Return a target constant with the specified
  // value, of type i32.
  inline SDValue getI32Imm(unsigned Imm) {
    return CurDAG->getTargetConstant(Imm, MVT::i32);
  }

  virtual bool SelectInlineAsmMemoryOperand(const SDValue &Op,
                                            char ConstraintCode,
                                            std::vector<SDValue> &OutOps);
};

}

bool LE1DAGToDAGISel::SelectAddri8(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  EVT VT = Addr.getValueType();
  SDLoc dl(Addr.getNode());

  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = cast<ConstantSDNode>(Addr.getOperand(1));

    if (CN->getZExtValue() == (CN->getZExtValue() & 0xFF)) {
      if (FrameIndexSDNode *FIN =
          dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), VT);
      else
        Base = Addr.getOperand(0);
      if (Addr.getOperand(1).getOpcode() == ISD::UNDEF)
        Offset = getI32Imm(0);
      else
        Offset = Addr.getOperand(1);

      std::cout << "SelectAddri8 pass, BaseWithConstantOFfset" << std::endl;
      return true;
    }
    std::cout << "BaseWithConstantOffset > 8 bits, SelectAddri8 fail"
      << std::endl;
  }
  else if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), VT);
    Offset = CurDAG->getTargetConstant(0, VT);
    std::cout << "Addr is FrameIndex, SelectAddri8 pass" << std::endl;
    return true;
  }
  else {
    SDValue LHS = Addr.getOperand(0);
    SDValue RHS = Addr.getOperand(1);
    Offset = getI32Imm(0);

    // The address may be stored in a single register
    if (LHS.getValueType() == MVT::Other) {
      Base = RHS;
      std::cout << "MVT::OTHER?!" << std::endl;
      return true;
    }
    else if (RHS.getValueType() == MVT::Other) {
      Base = LHS;
      std::cout << "MVT::OTHER?!" << std::endl;
      return true;
    }

    // Address has bee calculated which the base and offset stored in registers.
    // Add these values to create the base, and use a zero offset. We also check
    // whether we are adding the result of a shift, if so we can possibly use
    // one of our SHADD instructions.
    if ((LHS.getOpcode() != ISD::SHL) && (RHS.getOpcode() != ISD::SHL)) {
      Base = SDValue(CurDAG->getMachineNode(LE1::ADDr, dl, VT, LHS, RHS), 0);
      std::cout << "Creating ADDr node for address, SelectAddri8 pass"
        << std::endl;
      return true;
    }
    else {
      unsigned ShiftVal = 0;
      unsigned Opcode = 0;
      SDValue ShiftOp0;
      SDValue ShiftOp1;
      if (LHS.getOpcode() == ISD::SHL) {
        if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(LHS.getOperand(1))) {
          ShiftOp0 = LHS.getOperand(0);
          ShiftOp1 = RHS;
          ShiftVal = CN->getZExtValue();
        }
      }
      else if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(RHS.getOperand(1)))
      {
        ShiftOp0 = RHS.getOperand(0);
        ShiftOp1 = LHS;
        ShiftVal = CN->getZExtValue();
      }

      switch (ShiftVal) {
      default:
        Base = SDValue(CurDAG->getMachineNode(LE1::ADDr, dl, VT, LHS, RHS), 0);
        std::cout << "SelectAddri8 success, using ADDr" << std::endl;
        return true;
      case 1:
        Opcode = LE1::SH1ADDr;
        break;
      case 2:
        Opcode = LE1::SH2ADDr;
        break;
      case 3:
        Opcode = LE1::SH3ADDr;
        break;
      case 4:
        Opcode = LE1::SH4ADDr;
        break;
      }
      Base = SDValue(CurDAG->getMachineNode(Opcode, dl, VT, ShiftOp0,
                                            ShiftOp1), 0);
      std::cout << "Created shl op for addr, SelectAddri8 pass" << std::endl;
      return true;
    }
  }
  std::cout << "Fail on SelectAddri8" << std::endl;
  return false;
}

// TODO Add functionality such as the i8 version, probably refactor
bool LE1DAGToDAGISel::SelectAddri12(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  EVT ValTy = Addr.getValueType();

  if (CurDAG->isBaseWithConstantOffset(Addr)) {
    ConstantSDNode *CN = cast<ConstantSDNode>(Addr.getOperand(1));
    if (CN->getZExtValue() == (CN->getZExtValue() & 0xFFF)) {

      if (FrameIndexSDNode *FIN =
          dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
        Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), ValTy);
      else
        Base = Addr.getOperand(0);

      Offset = Addr.getOperand(1);
      std::cout << "SelectAddri12 success" << std::endl;
      return true;
    }
  }
  std::cout << "SelectAddri12 fail" << std::endl;
  return false;
}

bool LE1DAGToDAGISel::SelectAddri32(SDValue Addr, SDValue &Base,
                                    SDValue &Offset) {
  DEBUG(dbgs() << "SelectAddri32 with ");
  if (Addr.getNode()->isTargetOpcode())
    DEBUG(dbgs() <<
          TM.getTargetLowering()->getTargetNodeName(Addr.getOpcode()));
  else
    DEBUG(dbgs() << Addr.getNode()->getOperationName());
  DEBUG(dbgs() << "\n");

  SDLoc dl(Addr.getNode());
  if (dyn_cast<FrameIndexSDNode>(Addr)) {
    std::cout << "Addr is FrameIndex, SelectAddri32 fail" << std::endl;
    return false;
  }
  if (GlobalAddressSDNode *GA = dyn_cast<GlobalAddressSDNode>(Addr)) {
    Base = CurDAG->getTargetGlobalAddress(GA->getGlobal(), dl, MVT::i32, 0);
    Offset = CurDAG->getTargetConstant(GA->getOffset(), MVT::i32);
    std::cout << "GlobalAddress, SelectAddri32 success" << std::endl;
    return true;
  }
  std::cout << "SelectAddri32 fail" << std::endl;
  return false;
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* LE1DAGToDAGISel::Select(SDNode *Node) {

  unsigned Opcode = Node->getOpcode();
  SDLoc dl(Node);

  // Dump information about the Node being selected
  DEBUG(dbgs() << "Selecting:" << Opcode << "\n");
  DEBUG(Node->dump(CurDAG));

  switch(Opcode) {
  default:
    // Select the default instruction
    return SelectCode(Node);
    break;
    // FIXME ADDE should take a valid carry flag. This is an expanded op
    // in TargetLowering, should try to make it custom
  case ISD::ADDE: {
    /*
    // Lower ADDC to ADDCG but with zero moved in BReg
    SDValue InFlag = Node->getOperand(2);
    SDValue CmpLHS = Node->getOperand(0);
    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);
    EVT VT = LHS.getValueType();

    SDNode *Carry = CurDAG->getMachineNode(LE1::CMPLTU, dl, VT,
                                           CmpLHS, InFlag.getOperand(1));
    SDNode *AddCarry = CurDAG->getMachineNode(LE1::ADD, dl, VT,
                                              SDValue(Carry,0), RHS);
    return CurDAG->SelectNodeTo(Node, LE1::ADD, VT, MVT::Glue,
                                LHS, SDValue(AddCarry,0));
    */
    break;
  }
  case LE1ISD::ADDCG: {
    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);
    SDValue Cin = Node->getOperand(2);
    return CurDAG->getMachineNode(LE1::ADDCG, dl, MVT::i32, MVT::i1, 
                                  LHS, RHS, Cin);
    break;
  }
  case LE1ISD::DIVS: {
    SDValue LHS = Node->getOperand(0);
    SDValue RHS = Node->getOperand(1);
    SDValue Cin = Node->getOperand(2);
    return CurDAG->getMachineNode(LE1::DIVS, dl, MVT::i32, MVT::i1,
                                  LHS, RHS, Cin);
    break;
  }
    //FIXME instructions should be given node names so selection is automatic
  case LE1ISD::MTB:
    return CurDAG->getMachineNode(LE1::MTB, dl, MVT::i1, Node->getOperand(0));
    break;
 case LE1ISD::MFB:
    return CurDAG->getMachineNode(LE1::MFB, dl, MVT::i32, Node->getOperand(0));
    break;
  case LE1ISD::SET_ATTR: {
    SDValue Chain = Node->getOperand(0);
    SDValue Value = Node->getOperand(1);
    SDValue Addr = Node->getOperand(2);
    SDNode *Result = CurDAG->getMachineNode(LE1::SetAttr, dl, MVT::Other,
                                            Value, Addr, Chain);
    //ReplaceUses(Node, Result);
    return Result;
    break;
  }
  case LE1ISD::NUM_CORES:
    return CurDAG->getMachineNode(LE1::LE1_NUM_CORES, dl, MVT::i32);
  }
  return SelectCode(Node);
}

bool LE1DAGToDAGISel::
SelectInlineAsmMemoryOperand(const SDValue &Op, char ConstraintCode,
                             std::vector<SDValue> &OutOps) {
  assert(ConstraintCode == 'm' && "unexpected asm memory constraint");
  OutOps.push_back(Op);
  return false;
}

/// createLE1ISelDag - This pass converts a legalized DAG into a
/// LE1-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createLE1ISelDag(LE1TargetMachine &TM) {
  return new LE1DAGToDAGISel(TM);
}
